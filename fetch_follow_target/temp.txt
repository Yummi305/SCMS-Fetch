#include <ros/ros.h>
#include <geometry_msgs/Twist.h>
#include <geometry_msgs/Vector3Stamped.h>
#include <tf/transform_listener.h>
#include <cmath>
#include <chrono>
#include <vector>

class Marker{
    public:
    geometry_msgs::Vector3Stamped pos; // x,y.z positions
    double distance; //track object distance in 3d space
    const double camOffset = 0.1088; // offset of Fetches camera frame in m
    double shortDist; //
    bool detected; //set if fetch has detected target
    bool reached; //set if fetch as reached target
};

Marker marker;

//Callback function to receive marker position
void tagCallback(const geometry_msgs::Vector3Stamped::ConstPtr& msg){
    // retrieve marker's position and orientation
    double marker_x = msg->vector.x;
    double marker_y = msg->vector.y;
    double marker_z = msg->vector.z;
    double marker_yaw = 0;

    // Define a transform from marker frame to robot frame
    tf::Transform transform;
    transform.setorigin(tf::Vector3(marker_x, marker_y, marker_z));
    tf::Quatenion q;
    q.setRPY(0,0,marker_yaw);

    // Look up transform from base_link to marker_frame
    tf::TransformListener listener;
    tf::StampedTransform robot_to_marker;
    try{
        listener.lookupTransform("base_link", "marker_frame",ros::time(0),robot_to_marker);
    } catch (tf::TransformException& ex) {
        ROs_ERROR("Error %s", ex.what());
        return;
    }

    tf::Transform marker_in_robot = robot_to_marker * transform;

    double distance = marker_in_robot.getOrigin().length();

}

int main(int argc, char** argv){
    ros::init(argc, argv, "followTarget");
    ros::NodeHandle nh;
    ros::Subscriber tag_sub = nh.subscribe("/acuro_single/position", 1000, tagCallback);
    ros::Publisher cmd_pub = nh.advertise<geometry_msgs::Twist>("cmd_vel", 1);
    ros::spin();

    return 0;
}

    void markerCallback(const geometry_msgs::PoseStamped::ConstPtr& msg){
        double target_distance = DistanceToMarker(msg->vector);
        geometry_msgs::Twist cmd_vel;
        if (target_distance > target_distance_threshold){
            cmd_vel.linear.x = 0.2;
            cmd_vel.angular.z = 0.1;
        } else {
            cmd_vel.linear.x = 0.0;
            cmd_vel.angular.z = 0.0;
        }

        cmd_vel_pub.publish(cmd_vel);
    }

    double DistanceToMarker(const geometry_msgs::Vector3StampedPtr& msg){

    }